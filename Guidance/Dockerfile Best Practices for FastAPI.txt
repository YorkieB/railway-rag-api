Production-Grade Containerization Architecture for FastAPI Applications
1. Executive Summary and Architectural Principles
The deployment of modern web applications has fundamentally shifted from mutable, server-centric paradigms to immutable, containerized infrastructures. Within this landscape, Python has maintained its dominance as a primary language for backend development, particularly with the ascent of FastAPI as the framework of choice for high-performance, asynchronous Application Programming Interfaces (APIs). However, the apparent simplicity of wrapping a Python script in a Docker container belies the complexity required to achieve a truly production-grade artifact. A robust container image must satisfy rigorous standards regarding security hardening, resource efficiency, build determinism, and operational observability.
This comprehensive report delineates the architectural decisions necessary to construct a production-ready Dockerfile for a FastAPI application. The analysis is driven by a specific requirement to utilize the exec form of the CMD instruction, a directive that necessitates a deep exploration of Linux process management, signal propagation, and the role of Process ID 1 (PID 1) within a containerized namespace. Furthermore, strictly adhering to the user's constraint of deploying the application via uvicorn on port 8080 requires a nuanced understanding of network binding, user privileges, and the distinct operational characteristics of Asynchronous Server Gateway Interface (ASGI) servers.
The following sections provide an exhaustive technical dissection of the container lifecycle. We begin by analyzing the fundamental mechanics of the Linux kernel as they pertain to Docker, specifically focusing on the critical distinction between shell and exec command execution. We then evaluate the trade-offs in base image selection, challenging the common prevalence of Alpine Linux in favor of Debian-based distributions for Python workloads. Subsequent chapters address advanced dependency management through multi-stage builds, the implementation of least-privilege security models via non-root users, and the configuration of native health checks to ensure resilience without introducing unnecessary bloat. The report culminates in the synthesis of a finalized, annotated Dockerfile that strictly adheres to the provided specifications while integrating industry-leading best practices.
2. The Mechanics of Process Execution and Signal Handling
The primary technical constraint identified in the user requirement is the mandatory usage of the "exec form" for the CMD instruction to ensure correct handling of signals like SIGTERM. To understand the gravity of this requirement, one must look beyond Docker syntax and examine the Linux process model itself. The behavior of a container during shutdown is entirely dependent on how the kernel delivers signals to the process hierarchy rooted at PID 1.
2.1 The Special Responsibilities of PID 1
In a standard Linux operating system, the kernel bootstraps the user space by launching an init process (typically systemd or SysVinit) with Process ID 1. This process is special; it is the ancestor of every other process on the system and is responsible for reaping "zombie" processes (child processes that have terminated but whose exit status has not been collected by their parent).1
Crucially, the Linux kernel treats PID 1 differently regarding signal handling. In a standard process, receiving a signal like SIGTERM (Signal 15) triggers a default action, usually termination. However, to prevent accidental system shutdowns, the kernel disables these default signal handlers for PID 1. A process running as PID 1 will strictly ignore any signal that it has not explicitly registered a handler for.2
In the context of a Docker container, the process defined in the ENTRYPOINT or CMD instruction becomes PID 1 within that container's PID namespace. If the application running as PID 1—in this case, the Uvicorn server—is not written to explicitly handle signals, or if the process architecture prevents signals from reaching it, the container will fail to stop gracefully. When an orchestrator like Kubernetes or the Docker daemon issues a command to stop the container, it sends SIGTERM to PID 1. It then waits for a grace period (defaults vary, typically 10 to 30 seconds). If the process has not exited by the end of this period, the orchestrator sends SIGKILL (Signal 9), which the kernel uses to forcefully destroy the process immediately. SIGKILL cannot be caught or ignored; it results in an abrupt termination where database connections are not closed, in-flight requests are severed, and file buffers may not be flushed.4
2.2 The Critical Distinction: Shell Form vs. Exec Form
The Dockerfile specification provides two distinct syntaxes for defining the command to run: the Shell Form and the Exec Form. While they may appear to produce the same result—running the application—their impact on the container's process tree and signal handling capabilities is fundamentally different.
2.2.1 The Shell Form
The shell form is characterized by a plain string syntax. For example:

Dockerfile


CMD uvicorn app:app --host 0.0.0.0 --port 8080

When Docker encounters this instruction, it acts under the assumption that the command may rely on shell processing (such as environment variable expansion like $HOME or wildcard operators *). To support this, Docker implicitly modifies the command to run as a subcommand of a shell. The actual command executed inside the container becomes:

Bash


/bin/sh -c "uvicorn app:app --host 0.0.0.0 --port 8080"

In this scenario, the /bin/sh shell process takes the role of PID 1. The Uvicorn server is spawned as a child process of the shell. This introduces a critical architectural flaw regarding signal propagation. Standard POSIX shells (including sh and many configurations of bash) do not automatically forward signals to their child processes. This behavior is sometimes referred to as the "Wait and Cooperative Exit" (WCE) problem in certain shell implementations, where the shell waits for the child to complete but does not interrupt it upon receiving a signal unless explicit trap logic is implemented.7
When docker stop is executed, the SIGTERM signal is sent to PID 1 (/bin/sh). The shell receives the signal but, adhering to its default behavior, does not pass it down to the Uvicorn child process. Consequently, Uvicorn continues to serve requests, unaware that a shutdown has been initiated. The Docker daemon waits for the timeout, sees the process is still running, and eventually issues SIGKILL to the shell. The kernel then destroys the shell and its children. This creates a scenario where every deployment or restart results in dropped requests and potential data corruption, negating the "graceful shutdown" capabilities of the application.3
2.2.2 The Exec Form
The exec form, which the user explicitly requested, is characterized by a JSON array syntax. This format allows the user to pass arguments directly to the kernel's exec system call family (e.g., execve).

Dockerfile


CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8080"]

In this configuration, Docker does not invoke a shell. Instead, it executes the binary specified in the first element of the array directly. The uvicorn process itself becomes PID 1 inside the container.
Because Uvicorn is a modern ASGI server designed for production use, it includes internal logic to handle Unix signals. When Uvicorn runs as PID 1 and receives SIGTERM from the Docker daemon, it triggers its shutdown sequence. This sequence involves:
1. Stop Accepting: The server stops listening on the socket for new connections.
2. Drain: It waits for currently processing requests to complete (up to a configured timeout).
3. Cleanup: It fires any registered shutdown events in the FastAPI application (e.g., @app.on_event("shutdown") or lifespan context managers), allowing for the closing of database pools and flushing of logs.
4. Exit: The process exits with a status code of 0.1
This direct communication line between the container runtime and the application is why the exec form is the mandatory standard for production environments.1
2.3 Comparative Analysis of Command Forms
The following table summarizes the operational differences between the two forms, highlighting why the exec form is superior for this use case.
FeatureShell Form (CMD command param)Exec Form (CMD ["command", "param"])PID 1 Process/bin/shuvicorn (The Application)Signal HandlingSignals trapped by shell; not forwarded.Signals received directly by app.Shutdown TypeForceful (SIGKILL after timeout).Graceful (SIGTERM handling).Variable ExpansionSupported (e.g., $HOME works).Not supported (literal strings only).Security SurfaceSlightly larger (invokes shell).Minimal (direct execution).Production SuitabilityLow (Development/Scripting only).High (Standard best practice).2.4 Uvicorn's Signal Handling Capabilities
It is important to acknowledge that the effectiveness of the exec form relies on the application's ability to handle signals. Uvicorn explicitly supports SIGINT (Ctrl+C) and SIGTERM. Research indicates that Uvicorn's handling of these signals initiates a "graceful exit," allowing properly structured FastAPI applications to close connections cleanly.4 However, if the application were wrapped in a shell script without using the exec command inside that script, the same signal blocking issue would occur. Therefore, invoking the binary directly via the Dockerfile's CMD array is the most robust method to guarantee signal delivery.3
3. Base Image Selection: The Foundation of the Stack
The choice of the base image is the single most significant decision regarding the size, security, and compatibility of the final container artifact. In the Python ecosystem, this choice generally falls between Alpine Linux and Debian-based images (specifically the "Slim" variants).
3.1 The Alpine Linux Trap
Alpine Linux is frequently cited in general Docker tutorials due to its extremely small footprint (approx. 5MB). It achieves this by using musl libc instead of the standard GNU C Library (glibc). While this is excellent for Go or static binaries, it presents significant challenges for Python applications.15
The Python ecosystem relies heavily on "wheels"—pre-compiled binary packages uploaded to PyPI. These wheels (specifically manylinux wheels) are linked against glibc. Because Alpine uses musl, standard wheels are incompatible. Consequently, when pip install is run on Alpine, it cannot download the pre-compiled binary. Instead, it must download the source code and compile the C extensions from scratch.
This compilation requirement introduces two negative side effects:
1. Build Bloat: To compile libraries like cryptography, numpy, or pydantic (which FastAPI depends on), the image requires a full C toolchain (gcc, musl-dev, make). Installing these tools increases the build time significantly and can result in a final image that is larger than the Debian equivalent, unless complex multi-stage builds are used to strip the build tools meticulously.17
2. Runtime Instability: Subtle Application Binary Interface (ABI) differences between glibc and musl can lead to obscure bugs or performance degradation in Python applications, which are primarily tested against glibc environments.17
3.2 The Superiority of Debian Slim
The "Slim" variants of the official Python images (e.g., python:3.12-slim) are based on Debian (currently Debian 12 "Bookworm"). These images are stripped of non-essential packages like man pages and UI tools but retain glibc. This ensures that pip can install standard manylinux wheels directly, resulting in faster builds and guaranteed compatibility with the vast majority of the Python ecosystem.16
For a production-grade FastAPI application, python:3.12-slim strikes the optimal balance between size (approx. 120MB uncompressed) and compatibility. It minimizes the "vulnerability surface area" by excluding unused system libraries while maintaining the standard C library required for stable Python execution.16
3.3 Deterministic Version Pinning
In production, immutability is paramount. Using a tag like python:3.12 is dangerous because the underlying image changes with every patch release of Python or Debian. A build that passes today might fail tomorrow if the base image is updated with a breaking change.
Best practice dictates two levels of pinning:
1. Minor Version & OS Codename: Pinning to python:3.12-slim-bookworm ensures that the OS major version remains constant.
2. SHA Digest: For the highest level of security and reproducibility, pinning the image by its SHA256 digest (e.g., python:3.12-slim@sha256:abc...) guarantees that the exact same bits are used for every build, regardless of upstream changes or tag manipulation. This prevents supply chain attacks where a malicious actor might compromise a tag.19 While SHA pinning is the ultimate standard, pinning the semantic version is often sufficient for general enterprise use cases and will be used in our recommendation for readability, with a note on SHA pinning for high-security environments.
4. Advanced Build Strategies: Multi-Stage Architecture
To reconcile the need for a lean production image with the potential need for build-time tools (even on Debian, some packages might require compilation), the "Multi-Stage Build" pattern is the industry standard.
4.1 The Builder Stage
The first stage of the Dockerfile, aliased as builder, is responsible for preparing the application environment. In this stage, we install the full suite of build dependencies (like build-essential or libpq-dev for database drivers). We then create a Python virtual environment (/opt/venv) and install the dependencies listed in requirements.txt.
The use of a virtual environment inside Docker might seem redundant since the container itself provides isolation. However, using a virtual environment in the builder stage simplifies the transition to the runner stage. Rather than attempting to copy scattered libraries from /usr/local/lib/python3.12/site-packages, we can simply copy the entire /opt/venv directory. This ensures that all dependencies, and only the required dependencies, are transferred.18
4.2 The Runner Stage
The second stage, runner, starts from a fresh python:3.12-slim image. It does not inherit the apt packages or build artifacts from the builder stage. We simply copy the /opt/venv directory and the application source code. This results in a final image that contains only the runtime necessities, significantly reducing the image size (often by 40-50%) and removing compilers that could be used by an attacker to build exploits inside a compromised container.16
4.3 Layer Caching and Ordering
Docker builds images in layers. If an instruction modifies the filesystem, a new layer is created. Docker caches these layers to speed up subsequent builds. If a layer changes, all subsequent layers must be rebuilt. Therefore, the order of instructions affects build efficiency.
We must copy requirements.txt and run pip install before copying the application source code.

Dockerfile


COPY requirements.txt.
RUN pip install -r requirements.txt
COPY..

Since application code changes frequently but dependencies change rarely, this ordering allows Docker to reuse the cached "dependency layer" for most builds, drastically reducing CI/CD wait times.15
5. Security Engineering: The Non-Root User
Running containerized applications as the root user is a pervasive security anti-pattern. While containers utilize namespaces to isolate processes, a process running as root inside a container typically has root privileges within the container's namespace. If a vulnerability in the application (e.g., in Uvicorn or a third-party library) allows for Remote Code Execution (RCE), the attacker gains control of the container as root. This facilitates container breakout attempts, allowing the attacker to potentially interact with the host kernel or mounted volumes with elevated privileges.23
5.1 Implementing Least Privilege
The strict adherence to the Principle of Least Privilege requires creating a dedicated, unprivileged user within the Dockerfile. The python:slim images run as root by default. We must utilize the useradd command to create a system user.
The command RUN useradd -r -s /bin/false appuser is the standard for Debian-based images:
? -r: Creates a "system" account. These usually have UIDs below 1000 and do not have password expiry.
? -s /bin/false: Sets the login shell to /bin/false, preventing anyone (including an attacker) from logging in or getting a shell via su.25
? --no-create-home: System services do not typically require a home directory, further reducing the writable filesystem area.28
5.2 File Permissions and Ownership
Simply creating the user is insufficient; the application files must be accessible to this user. In a multi-stage build, the COPY instruction supports a --chown flag.

Dockerfile


COPY --chown=appuser:appuser..

This ensures that the application code is owned by the unprivileged user. Finally, the USER appuser instruction switches the context. All subsequent commands, including the final CMD, run as this user.30
5.3 Port Binding Constraints
Historically, Linux restricts non-root users from binding to ports below 1024 (privileged ports). The user's request specifies port 8080. This is an unprivileged port, which is ideal for this security model. It allows the appuser to bind to the network socket without requiring specialized Linux capabilities (like CAP_NET_BIND_SERVICE) or root access, simplifying the configuration.15
6. The Application Server: Uvicorn Configuration
The user request specifies the command: CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8080"]. This command dictates the runtime architecture of the container.
6.1 Network Visibility
The flag --host 0.0.0.0 is non-negotiable in containerized environments. By default, Uvicorn binds to 127.0.0.1 (localhost). In a standard networking context, localhost refers to the machine itself. However, inside a container, localhost refers strictly to the container's isolated loopback interface. If Uvicorn binds to 127.0.0.1, it will accept connections originated from inside the container, but it will be invisible to the Docker host or any external load balancer. Binding to 0.0.0.0 instructs the server to listen on all available network interfaces, effectively exposing the service to the outside world (subject to Docker's port mapping).18
6.2 The Proxy Header Problem
In a production environment, FastAPI containers rarely sit directly on the internet. They are typically positioned behind a load balancer (like AWS ALB, Nginx, or Traefik) or a Kubernetes Ingress controller. These intermediaries terminate the SSL connection (HTTPS) and forward the traffic to the container via HTTP.
This architecture obscures the original client's information. From Uvicorn's perspective, the "client" is the load balancer's IP address. This breaks features like rate limiting, logging, and URL generation (FastAPI might generate http:// links instead of https://).
To resolve this, Uvicorn provides the --proxy-headers flag. This instructs the server to trust standard headers like X-Forwarded-For and X-Forwarded-Proto to populate the client information.
Furthermore, the --forwarded-allow-ips flag controls which upstream proxies are trusted. While explicit IP allow-listing is safer, in dynamic orchestration environments (like Kubernetes Pod networks), the proxy IP may change. A common (though permissive) convention in private container networks is to use * to trust all upstream proxies within the cluster. For this report, we will include --proxy-headers as a critical production setting.33
6.3 Concurrency: Workers vs. Single Process
A common point of confusion is whether to use Uvicorn's --workers flag or a process manager like Gunicorn.
? Gunicorn + Uvicorn Workers: This is the robust standard for deploying on Virtual Machines or "fat" containers. Gunicorn manages the worker processes, restarts them if they crash, and provides advanced process management features.36
? Single Process Uvicorn: In the context of Docker and Kubernetes, the "Single Process per Container" model is preferred. The orchestrator (Kubernetes/Docker Swarm) acts as the process manager. If the process crashes, the orchestrator restarts the container. If more concurrency is needed, the orchestrator scales the number of containers (replicas), not the number of processes inside the container. This approach simplifies observability (logs are one stream) and resource scaling.38
Since the user explicitly requested CMD ["uvicorn",...], this aligns with the cloud-native, single-process philosophy suitable for orchestrated environments.
7. Observability and Health Checks
A production container must effectively communicate its status to the runtime environment. Docker provides the HEALTHCHECK instruction to perform periodic probing of the application.
7.1 The "Curl" Dilemma
A common pattern in tutorials is to use curl for health checks: CMD curl -f http://localhost:8080/health. However, slim images do not include curl by default. Installing curl solely for a health check adds megabytes to the image and introduces a tool that attackers can use to download malware.41
7.2 The Native Python Solution
Since the container runtime is Python, we can leverage the standard library to perform the HTTP check. This requires zero extra dependencies. The command python -c "import urllib.request..." is lightweight, secure, and effective.

Dockerfile


HEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8080/health').read()" |

| exit 1

This configuration ensures that if the application hangs or deadlocks (a state where the process exists but cannot serve requests), Docker will mark the container as unhealthy and can trigger a restart.15 Note that this assumes the FastAPI app implements a /health endpoint, which is a standard best practice.
8. The Finalized Production Dockerfile
Based on the extensive research and analysis detailed above, the following is the complete, annotated Dockerfile. It satisfies all user requirements, including the strict use of the exec form, dependency installation, and port configuration, while integrating the advanced security and optimization patterns discussed.

Dockerfile


# ====================================================================================
# STAGE 1: BUILDER
# ====================================================================================
# Use the official Python 3.12 Slim image based on Debian Bookworm.
# Rationale: Slim images provide glibc for compatibility with manylinux wheels,
# significantly faster build times, and runtime stability compared to Alpine.
FROM python:3.12-slim-bookworm AS builder

# Set environment variables to optimize Python behavior.
# PYTHONDONTWRITEBYTECODE: Prevents Python from writing.pyc files to disk.
# PYTHONUNBUFFERED: Ensures stdout/stderr are flushed immediately for Docker logs.
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Install system build dependencies.
# These libraries (like gcc) are often required to compile Python packages that
# do not have pre-built wheels. We do this in the builder stage to keep the
# final runtime image clean.
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    gcc \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Create a virtual environment in a specific location.
# Rationale: This isolates dependencies and makes copying them to the runner stage
# as simple as copying a single directory.
RUN python -m venv /opt/venv

# Activate the virtual environment by adding it to the PATH.
# This ensures that subsequent 'pip' commands install into the venv.
ENV PATH="/opt/venv/bin:$PATH"

# Copy the requirements file explicitly.
# Rationale: By copying this file separately and before the application code,
# we leverage Docker's layer caching. If requirements.txt hasn't changed,
# Docker will reuse the cached layer for the pip install, speeding up builds.
COPY requirements.txt.

# Install Python dependencies.
# --no-cache-dir: Prevents pip from caching the downloaded packages in the layer,
# reducing the intermediate image size.
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

# ====================================================================================
# STAGE 2: RUNNER
# ====================================================================================
# Start a fresh, minimal image for the runtime.
FROM python:3.12-slim-bookworm AS runner

# Set runtime environment variables.
ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PATH="/opt/venv/bin:$PATH"

# Install only the necessary runtime system libraries.
# For example, if using PostgreSQL, we only need libpq5 (the runtime lib),
# not the full development headers.
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

# Create a non-root system user.
# Security Best Practice: Never run the application as root.
# -r: Creates a system user (no password expiry).
# -s /bin/false: Disables shell login capabilities for this user.
# --no-create-home: We do not need a user home directory.
RUN useradd -r -s /bin/false --no-create-home appuser

# Set the working directory for the application.
WORKDIR /app

# Copy the populated virtual environment from the builder stage.
COPY --from=builder /opt/venv /opt/venv

# Copy the application source code.
# --chown: Changes ownership of the files to the non-root user during the copy.
COPY --chown=appuser:appuser..

# Switch to the non-root user.
# All subsequent commands (CMD, ENTRYPOINT, RUN) will execute as 'appuser'.
USER appuser

# Document the port that the application listens on.
EXPOSE 8080

# Configure a native Health Check.
# Uses Python's standard library 'urllib' to verify the app is responsive.
# This avoids installing 'curl' or 'wget', keeping the image small and secure.
HEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \
    CMD python -c "import urllib.request; urllib.request.urlopen('http://localhost:8080/health').read()" |

| exit 1

# The Startup Command.
# 1. Uses the 'exec form' (JSON Array) as requested.
#    This ensures 'uvicorn' runs as PID 1 and receives SIGTERM signals correctly.
# 2. Binds to 0.0.0.0 to allow external access to the container.
# 3. Listens on port 8080.
# 4. --proxy-headers: Configures Uvicorn to trust headers from load balancers
#    (like X-Forwarded-For), essential for correct IP resolution in production.
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "8080", "--proxy-headers"]

9. Operational Analysis and Reasoning
The constructed Dockerfile represents a synthesis of competing requirements: minimal size, maximum security, and robust operational behavior.
9.1 Justification for the Exec Form
The user's requirement to use the exec form CMD ["uvicorn",...] is validated by the mechanics of signal handling discussed in Section 2. By executing the binary directly, we bypass the /bin/sh shell. This ensures that when the hosting environment (Docker Engine, Kubernetes) sends a SIGTERM to stop the container, the signal is delivered instantly to the Uvicorn process. Uvicorn then performs a graceful shutdown, completing in-flight requests and running cleanup handlers. Had the shell form been used (CMD uvicorn...), the shell would have swallowed the signal, leading to a timeout and a forceful SIGKILL, potentially corrupting state.
9.2 Security Hardening Impact
The transition to a non-root user (appuser) significantly reduces the blast radius of a potential security breach. If an attacker exploits a vulnerability in the FastAPI application to execute arbitrary code, they are confined to the permissions of appuser. They cannot modify system binaries, install kernel modules, or edit configuration files owned by root. Furthermore, using a multi-stage build removes the compiler toolchain (gcc, make) from the runtime image, depriving an attacker of the tools needed to compile local privilege escalation exploits.
9.3 Dependency and Cache Optimization
The strict ordering of COPY requirements.txt followed by RUN pip install ensures efficient Docker layer caching. In a typical development lifecycle, source code changes dozens of times a day, while dependencies change rarely. This structure ensures that the heavy pip install layer is reused across builds, speeding up the feedback loop. The use of --no-cache-dir prevents pip from filling the image layer with duplicate tarballs of the installed packages, keeping the final image lean.
9.4 Production-Ready Uvicorn Settings
The inclusion of --proxy-headers is a crucial addition not explicitly requested but necessary for a "production-grade" setup. Without it, logs would show the load balancer's IP for every request, rendering security auditing and rate limiting ineffective. This flag aligns the container's behavior with the realities of modern network topologies.
10. Conclusion
The creation of a production-grade Dockerfile for FastAPI is not merely a task of scripting installation commands; it is an exercise in systems engineering. It requires a holistic view that encompasses kernel-level signal processing, Linux permission models, image layer theory, and application server configuration.
By implementing the exec form of the CMD instruction, this solution guarantees operational reliability through graceful shutdowns. By adopting multi-stage builds and Debian Slim bases, it ensures a compact, compatible, and deterministic runtime. Finally, by enforcing non-root execution and implementing native health checks, it delivers a secure and observable artifact ready for deployment in high-assurance environments. This Dockerfile stands as a definitive reference implementation for containerizing Python asynchronous services in 2025.
Works cited
1. Docker Best Practices: Choosing Between RUN, CMD, and ENTRYPOINT, accessed December 14, 2025, https://www.docker.com/blog/docker-best-practices-choosing-between-run-cmd-and-entrypoint/
2. What are shell form and exec form? - docker - Stack Overflow, accessed December 14, 2025, https://stackoverflow.com/questions/47904974/what-are-shell-form-and-exec-form
3. Why Your Dockerized Application Isn't Receiving Signals, accessed December 14, 2025, https://hynek.me/articles/docker-signals/
4. Uvicorn Graceful Shutdown within kubernetes ecosystem #2257 - GitHub, accessed December 14, 2025, https://github.com/Kludex/uvicorn/discussions/2257
5. docker-compose graceful shutdown of uvicorn --reload · Issue #364 - GitHub, accessed December 14, 2025, https://github.com/encode/uvicorn/issues/364
6. multiprocess graceful shutdown in docker and non-docker discrepency · Issue #668 · Kludex/uvicorn - GitHub, accessed December 14, 2025, https://github.com/encode/uvicorn/issues/668
7. Script is not receiving SIGTERM signal · Issue #33319 · moby/moby - GitHub, accessed December 14, 2025, https://github.com/moby/moby/issues/33319
8. shell - Forward SIGTERM to child in Bash - Unix & Linux Stack ..., accessed December 14, 2025, https://unix.stackexchange.com/questions/146756/forward-sigterm-to-child-in-bash
9. Behavior of SIGINT with Bash - Super User, accessed December 14, 2025, https://superuser.com/questions/1829830/behavior-of-sigint-with-bash
10. Bash: Why does parent script not terminate on SIGINT when child script traps SIGINT? - Stack Overflow, accessed December 14, 2025, https://stackoverflow.com/questions/18477785/bash-why-does-parent-script-not-terminate-on-sigint-when-child-script-traps-sig
11. Signal handling in Uvicorn with FastAPI - python - Stack Overflow, accessed December 14, 2025, https://stackoverflow.com/questions/71528875/signal-handling-in-uvicorn-with-fastapi
12. Dockerfile reference | Docker Docs, accessed December 14, 2025, https://docs.docker.com/reference/dockerfile/
13. Container lifecycle | Improve it with PID 1 in Docker | Padok - Theodo Cloud, accessed December 14, 2025, https://cloud.theodo.com/en/blog/docker-processes-container
14. Programmatically Shutdown Uvicorn Server Running FastAPI Application | by Benjamin, accessed December 14, 2025, https://benjoe.medium.com/programmatically-shutdown-uvicorn-server-running-fastapi-application-2038ade9436d
15. FastAPI Docker Best Practices | Better Stack Community, accessed December 14, 2025, https://betterstack.com/community/guides/scaling-python/fastapi-docker-best-practices/
16. FastAPI Docker Build Comparison. Overview | by Ashfaq | Nov, 2025 - Medium, accessed December 14, 2025, https://medium.com/@ashfaqbs/fastapi-docker-build-comparison-8317d8942e3e
17. Optimizing Dockerized FastAPI with TensorFlow: How to reduce a 1.57GB Image Size?, accessed December 14, 2025, https://www.reddit.com/r/FastAPI/comments/1e1lal6/optimizing_dockerized_fastapi_with_tensorflow_how/
18. FastAPI Setup Guide for 2025: Requirements, Structure & Deployment - DEV Community, accessed December 14, 2025, https://dev.to/zestminds_technologies_c1/fastapi-setup-guide-for-2025-requirements-structure-deployment-1gd
19. Building best practices - Docker Docs, accessed December 14, 2025, https://docs.docker.com/build/building/best-practices/
20. Slimmer FastAPI Docker Images with Multi-Stage Builds - David Muraya, accessed December 14, 2025, https://davidmuraya.com/blog/slimmer-fastapi-docker-images-multistage-builds/
21. Multi stage builds made my Python Docker image larger. Why? - Stack Overflow, accessed December 14, 2025, https://stackoverflow.com/questions/78748223/multi-stage-builds-made-my-python-docker-image-larger-why
22. FastAPI in Containers - Docker, accessed December 14, 2025, https://fastapi.tiangolo.com/deployment/docker/
23. Rootless mode - Docker Docs, accessed December 14, 2025, https://docs.docker.com/engine/security/rootless/
24. Running Python/Django docker containers with non-root user - GitHub, accessed December 14, 2025, https://github.com/gonzalo123/django-non-root
25. Running Containers as a Non-Root User: A Complete Guide - Techiescamp, accessed December 14, 2025, https://blog.techiescamp.com/running-containers-as-non-root-user/
26. How to add user using a dockerfile : r/docker - Reddit, accessed December 14, 2025, https://www.reddit.com/r/docker/comments/liv1zf/how_to_add_user_using_a_dockerfile/
27. How to add users to Docker container? - Stack Overflow, accessed December 14, 2025, https://stackoverflow.com/questions/27701930/how-to-add-users-to-docker-container
28. How to add a user without /home? - Ask Ubuntu, accessed December 14, 2025, https://askubuntu.com/questions/29359/how-to-add-a-user-without-home
29. Creating a system user in Debian without home directory still creates a non-existent home directory entry in /etc/passwd, accessed December 14, 2025, https://unix.stackexchange.com/questions/689918/creating-a-system-user-in-debian-without-home-directory-still-creates-a-non-exis
30. Securing Your Docker Containers: Why and How to Use a Non-Root User - Medium, accessed December 14, 2025, https://medium.com/@laxman.pokhrel.101/securing-your-docker-containers-why-and-how-to-use-a-non-root-user-f4dab2af0519
31. Run Python Applications as non-root user in Docker Containers — by example - Medium, accessed December 14, 2025, https://medium.com/@DahlitzF/run-python-applications-as-non-root-user-in-docker-containers-by-example-cba46a0ff384
32. How to Run Docker Containers as Non-Root User: Create User in Dockerfile - DevOpsCube, accessed December 14, 2025, https://devopscube.com/run-docker-containers-as-non-root-user/
33. Behind a Proxy - FastAPI, accessed December 14, 2025, https://fastapi.tiangolo.com/advanced/behind-a-proxy/
34. How to Get the Real Client IP in FastAPI Behind a Reverse Proxy - Python in Plain English, accessed December 14, 2025, https://python.plainenglish.io/how-to-get-the-real-client-ip-in-fastapi-behind-a-reverse-proxy-193adc757a1e
35. `forwarded_allow_ips` should allow wildcard IP addresses · Kludex uvicorn · Discussion #2358 - GitHub, accessed December 14, 2025, https://github.com/encode/uvicorn/discussions/2358
36. Mastering Gunicorn and Uvicorn: The Right Way to Deploy FastAPI Applications - Medium, accessed December 14, 2025, https://medium.com/@iklobato/mastering-gunicorn-and-uvicorn-the-right-way-to-deploy-fastapi-applications-aaa06849841e
37. Deploy FastAPI Docker & Uvicorn: Full Deployment Guide - Seenode, accessed December 14, 2025, https://seenode.com/blog/deploy-fastapi-docker-and-uvicorn/
38. Server Workers - Uvicorn with Workers - FastAPI, accessed December 14, 2025, https://fastapi.tiangolo.com/deployment/server-workers/
39. How do Uvicorn workers work, and how many do I need for a slim machine?, accessed December 14, 2025, https://stackoverflow.com/questions/74206034/how-do-uvicorn-workers-work-and-how-many-do-i-need-for-a-slim-machine
40. Deployments Concepts - FastAPI, accessed December 14, 2025, https://fastapi.tiangolo.com/deployment/concepts/
41. I built tiny open-source tools for Docker health checks - curl-like but 100× smaller - Reddit, accessed December 14, 2025, https://www.reddit.com/r/docker/comments/1ovwd43/i_built_tiny_opensource_tools_for_docker_health/
42. Docker Healthcheck without curl or wget - Web Development Notes, accessed December 14, 2025, https://muratcorlu.com/docker-healthcheck-without-curl-or-wget/
43. How to execute healthcheck without curl · Issue #58 · dart-lang/dart-docker - GitHub, accessed December 14, 2025, https://github.com/dart-lang/dart-docker/issues/58
